/*
 * sht1x.c - A SHT1x temperature and relative humidity sensor driver for tm4c123
 *
 * Copyright (c) 2014 Alexey Anisimov <zolkko@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with program.  If not, see <http://www.gnu.org/licenses/>
 */

/*
 * TODO: extract hardware dependent and utility functions into separate modules.
 */

#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>

#include <inc/tm4c123gh6pm.h>
#include <inc/hw_memmap.h>
#include <inc/hw_types.h>
#include <inc/hw_gpio.h>
#include <inc/hw_timer.h>

#include <driverlib/sysctl.h>
#include <driverlib/interrupt.h>
#include <driverlib/timer.h>
#include <driverlib/udma.h>
#include <driverlib/gpio.h>

#include "FreeRTOSConfig.h"

#include <FreeRTOS.h>
#include <semphr.h>

#include "sht1x.h"
#include "hw_udma_tbl.h"

/*
 * GPIO PORT Settings
 */
#define SHT1X_GPIO_PERIPH		SYSCTL_PERIPH_GPIOE

#define SHT1X_PORT_BASE			GPIO_PORTE_BASE

#define SHT1X_CLOCK_PIN			GPIO_PIN_1

#define SHT1X_DATA_OUT_PIN		GPIO_PIN_2

#define SHT1X_DATA_IN_PIN		GPIO_PIN_3

#define SHT1X_DIN_PIN_bp		(3)

#define SHT1X_DATA_INTERRUPT	GPIO_INT_PIN_3

#define SHT1X_GPIO_INTERRUPT	INT_GPIOE

#define SHT1X_BOTH_PINS			(SHT1X_CLOCK_PIN | SHT1X_DATA_OUT_PIN)

/*
 * TIMER Settings
 */
#define SHT1X_TIMER_PERIPH		SYSCTL_PERIPH_TIMER0

#define SHT1X_TIMER_BASE		TIMER0_BASE

#define SHT1X_TIMER				TIMER_A

#define SHT1X_TIMER_INTERRUPT	INT_TIMER0A

#define SHT1X_CLOCK_HZ			200000

/* Timer normal speed  */
#define SHT1X_CLK_NR			(configCPU_CLOCK_HZ / (SHT1X_CLOCK_HZ * 2))

/* Timer slow speed is used to create timeout operation */
#define SHT1X_CLK_LO			(configCPU_CLOCK_HZ / 1)


/*
 * uDMA Settings
 */
#define SHT1X_UDMA_PERIPH		SYSCTL_PERIPH_UDMA

#define SHT1X_DST_ADDRESS		((void *)(SHT1X_PORT_BASE + (GPIO_O_DATA + (SHT1X_BOTH_PINS << 2))))

#define SHT1X_UDMA_CHANNEL		UDMA_CHANNEL_TMR0A

#define SHT1X_UDMA_CH_NUM		UDMA_DEF_TMR0A_SEC_TMR1A

/*
 * Utility macros
 * TODO: remove redundant definitions and replace the rest of them with inline functions
 */
#define sht1x_clock_set()		GPIOPinWrite(SHT1X_PORT_BASE, SHT1X_CLOCK_PIN, SHT1X_CLOCK_PIN)
#define sht1x_clock_clear()		GPIOPinWrite(SHT1X_PORT_BASE, SHT1X_CLOCK_PIN, 0x00)
#define sht1x_data_out_set()	GPIOPinWrite(SHT1X_PORT_BASE, SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN)
#define sht1x_data_out_clear()	GPIOPinWrite(SHT1X_PORT_BASE, SHT1X_DATA_OUT_PIN, 0x00)
#define sht1x_data_in_get()		GPIOPinRead(SHT1X_PORT_BASE, SHT1X_DATA_IN_PIN)

/* Common definitions */
#define SHT1X_DEFAULT_STATUS		(0x00)

#define SHT1X_DEFAULT_CRC_INIT		(0x00)

#define SHT1X_PAYLOAD_BUFFER_SIZE	32

/*
 * State Indexes
 *
 * Please note that an order of the enum should correspond
 * to an order of array elements in states variable.
 */
typedef enum {
	SHT1X_SIDX_END = 0,
	SHT1X_SIDX_FAIL,

	/* Read Temperature */
	SHT1X_SIDX_SENSOR_FIN,
	SHT1X_SIDX_SENSOR_ACK,
	SHT1X_SIDX_SENSOR_ACKC,
	SHT1X_SIDX_SENSOR_ACKE,
	SHT1X_SIDX_SENSOR_WAIT_READY,

	SHT1X_SIDX_SENSOR_DATA_15,
	SHT1X_SIDX_SENSOR_DATA_15C,
	SHT1X_SIDX_SENSOR_DATA_14,
	SHT1X_SIDX_SENSOR_DATA_14C,
	SHT1X_SIDX_SENSOR_DATA_13,
	SHT1X_SIDX_SENSOR_DATA_13C,
	SHT1X_SIDX_SENSOR_DATA_12,
	SHT1X_SIDX_SENSOR_DATA_12C,
	SHT1X_SIDX_SENSOR_DATA_11,
	SHT1X_SIDX_SENSOR_DATA_11C,
	SHT1X_SIDX_SENSOR_DATA_10,
	SHT1X_SIDX_SENSOR_DATA_10C,
	SHT1X_SIDX_SENSOR_DATA_9,
	SHT1X_SIDX_SENSOR_DATA_9C,
	SHT1X_SIDX_SENSOR_DATA_8,
	SHT1X_SIDX_SENSOR_DATA_8C,

	SHT1X_SIDX_SENSOR_BYTE2_ACKS,
	SHT1X_SIDX_SENSOR_BYTE2_ACK,
	SHT1X_SIDX_SENSOR_BYTE2_ACKC,

	SHT1X_SIDX_SENSOR_DATA_7,
	SHT1X_SIDX_SENSOR_DATA_7C,
	SHT1X_SIDX_SENSOR_DATA_6,
	SHT1X_SIDX_SENSOR_DATA_6C,
	SHT1X_SIDX_SENSOR_DATA_5,
	SHT1X_SIDX_SENSOR_DATA_5C,
	SHT1X_SIDX_SENSOR_DATA_4,
	SHT1X_SIDX_SENSOR_DATA_4C,
	SHT1X_SIDX_SENSOR_DATA_3,
	SHT1X_SIDX_SENSOR_DATA_3C,
	SHT1X_SIDX_SENSOR_DATA_2,
	SHT1X_SIDX_SENSOR_DATA_2C,
	SHT1X_SIDX_SENSOR_DATA_1,
	SHT1X_SIDX_SENSOR_DATA_1C,
	SHT1X_SIDX_SENSOR_DATA_0,
	SHT1X_SIDX_SENSOR_DATA_0C,

	SHT1X_SIDX_SENSOR_BYTE1_ACKS,
	SHT1X_SIDX_SENSOR_BYTE1_ACK,
	SHT1X_SIDX_SENSOR_BYTE1_ACKC,

	SHT1X_SIDX_SENSOR_CRC_7,
	SHT1X_SIDX_SENSOR_CRC_7C,
	SHT1X_SIDX_SENSOR_CRC_6,
	SHT1X_SIDX_SENSOR_CRC_6C,
	SHT1X_SIDX_SENSOR_CRC_5,
	SHT1X_SIDX_SENSOR_CRC_5C,
	SHT1X_SIDX_SENSOR_CRC_4,
	SHT1X_SIDX_SENSOR_CRC_4C,
	SHT1X_SIDX_SENSOR_CRC_3,
	SHT1X_SIDX_SENSOR_CRC_3C,
	SHT1X_SIDX_SENSOR_CRC_2,
	SHT1X_SIDX_SENSOR_CRC_2C,
	SHT1X_SIDX_SENSOR_CRC_1,
	SHT1X_SIDX_SENSOR_CRC_1C,
	SHT1X_SIDX_SENSOR_CRC_0,
	SHT1X_SIDX_SENSOR_CRC_0C,

	SHT1X_SIDX_SENSOR_CRC_ACKS,
	SHT1X_SIDX_SENSOR_CRC_ACK,
	SHT1X_SIDX_SENSOR_CRC_ACKC,

	/* Status Register Read */
	SHT1X_SIDX_SREGR_FIN,
	SHT1X_SIDX_SREGR_ACK,
	SHT1X_SIDX_SREGR_ACKC,
	SHT1X_SIDX_SREGR_ACKE,

	SHT1X_SIDX_SREGR_DATA_7,
	SHT1X_SIDX_SREGR_DATA_7C,
	SHT1X_SIDX_SREGR_DATA_6,
	SHT1X_SIDX_SREGR_DATA_6C,
	SHT1X_SIDX_SREGR_DATA_5,
	SHT1X_SIDX_SREGR_DATA_5C,
	SHT1X_SIDX_SREGR_DATA_4,
	SHT1X_SIDX_SREGR_DATA_4C,
	SHT1X_SIDX_SREGR_DATA_3,
	SHT1X_SIDX_SREGR_DATA_3C,
	SHT1X_SIDX_SREGR_DATA_2,
	SHT1X_SIDX_SREGR_DATA_2C,
	SHT1X_SIDX_SREGR_DATA_1,
	SHT1X_SIDX_SREGR_DATA_1C,
	SHT1X_SIDX_SREGR_DATA_0,
	SHT1X_SIDX_SREGR_DATA_0C,

	SHT1X_SIDX_SREGR_DATA_ACKS,
	SHT1X_SIDX_SREGR_DATA_ACK,
	SHT1X_SIDX_SREGR_DATA_ACKC,

	SHT1X_SIDX_SREGR_CRC_7,
	SHT1X_SIDX_SREGR_CRC_7C,
	SHT1X_SIDX_SREGR_CRC_6,
	SHT1X_SIDX_SREGR_CRC_6C,
	SHT1X_SIDX_SREGR_CRC_5,
	SHT1X_SIDX_SREGR_CRC_5C,
	SHT1X_SIDX_SREGR_CRC_4,
	SHT1X_SIDX_SREGR_CRC_4C,
	SHT1X_SIDX_SREGR_CRC_3,
	SHT1X_SIDX_SREGR_CRC_3C,
	SHT1X_SIDX_SREGR_CRC_2,
	SHT1X_SIDX_SREGR_CRC_2C,
	SHT1X_SIDX_SREGR_CRC_1,
	SHT1X_SIDX_SREGR_CRC_1C,
	SHT1X_SIDX_SREGR_CRC_0,
	SHT1X_SIDX_SREGR_CRC_0C,

	SHT1X_SIDX_SREGR_CRC_ACKS,
	SHT1X_SIDX_SREGR_CRC_ACK,
	SHT1X_SIDX_SREGR_CRC_ACKC,

	/* Status Register Write */
	SHT1X_SIDX_SREGW_FIN,
	SHT1X_SIDX_SREGW_ACK,
	SHT1X_SIDX_SREGW_ACKC,
	SHT1X_SIDX_SREGW_ACKE,

	SHT1X_SIDX_SREGW_PAYLOAD,
	SHT1X_SIDX_SREGW_PAYLOAD_FIN,
	SHT1X_SIDX_SREGW_PAYLOAD_ACK,
	SHT1X_SIDX_SREGW_PAYLOAD_ACKC,
	SHT1X_SIDX_SREGW_PAYLOAD_ACKE,

	/* Software Reset */
	SHT1X_SIDX_SOFT_RESET_FIN,
	SHT1X_SIDX_SOFT_RESET_ACK,
	SHT1X_SIDX_SOFT_RESET_ACKC,
	SHT1X_SIDX_SOFT_RESET_ACKE,
} sht1x_sidx_t;

/*
 * Types of output which a state produces.
 */
typedef enum {
	SHT1X_STATE_OUTPUT_NONE,
	SHT1X_STATE_OUTPUT_TIMER_ENABLE,
	SHT1X_STATE_OUTPUT_PAYLOAD,
	SHT1X_STATE_OUTPUT_INPUT_ACK_START,
	SHT1X_STATE_OUTPUT_INPUT_ACK_RISING_EDGE,
	SHT1X_STATE_OUTPUT_INPUT_ACK_FALLING_EDGE,
	SHT1X_STATE_OUTPUT_OUTPUT_ACK_START,
	SHT1X_STATE_OUTPUT_OUTPUT_ACK_RISING_EDGE,
	SHT1X_STATE_OUTPUT_OUTPUT_ACK_FALLING_EDGE,
	SHT1X_STATE_OUTPUT_OUTPUT_ACK_WAIT,
	SHT1X_STATE_OUTPUT_WAIT_READY,
	SHT1X_STATE_OUTPUT_READ_RISING_EDGE,
	SHT1X_STATE_OUTPUT_DATA_FALLING_EDGE,
	SHT1X_STATE_OUTPUT_CRC_FALLING_EDGE,
	SHT1X_STATE_OUTPUT_DONE,
} sht1x_state_output_t;


typedef struct {
	xSemaphoreHandle lock;
	xSemaphoreHandle interrupt_semaphore;

	sht1x_sidx_t state;
	sht1x_error_t error;

	uint16_t data;
	uint8_t crc;

	uint8_t status;
	uint8_t crc_init;

	uint8_t cmd[255];
	uint8_t cmd_payload[SHT1X_PAYLOAD_BUFFER_SIZE];
} sht1x_device_t;


typedef struct {
	sht1x_state_output_t output;
	sht1x_sidx_t next_state[2];
	sht1x_error_t next_error[2];
} sht1x_state_t;

/* Transmission start and Register address sequence pattern */
static const uint8_t trans_start_pattern[] = {
	/* reset sequence */
	SHT1X_DATA_OUT_PIN | SHT1X_CLOCK_PIN, SHT1X_DATA_OUT_PIN | SHT1X_CLOCK_PIN, SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN,
	SHT1X_DATA_OUT_PIN | SHT1X_CLOCK_PIN, SHT1X_DATA_OUT_PIN | SHT1X_CLOCK_PIN, SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN,
	SHT1X_DATA_OUT_PIN | SHT1X_CLOCK_PIN, SHT1X_DATA_OUT_PIN | SHT1X_CLOCK_PIN, SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN,
	SHT1X_DATA_OUT_PIN | SHT1X_CLOCK_PIN, SHT1X_DATA_OUT_PIN | SHT1X_CLOCK_PIN, SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN,
	SHT1X_DATA_OUT_PIN | SHT1X_CLOCK_PIN, SHT1X_DATA_OUT_PIN | SHT1X_CLOCK_PIN, SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN,
	SHT1X_DATA_OUT_PIN | SHT1X_CLOCK_PIN, SHT1X_DATA_OUT_PIN | SHT1X_CLOCK_PIN, SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN,
	SHT1X_DATA_OUT_PIN | SHT1X_CLOCK_PIN, SHT1X_DATA_OUT_PIN | SHT1X_CLOCK_PIN, SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN,
	SHT1X_DATA_OUT_PIN | SHT1X_CLOCK_PIN, SHT1X_DATA_OUT_PIN | SHT1X_CLOCK_PIN, SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN,
	SHT1X_DATA_OUT_PIN | SHT1X_CLOCK_PIN, SHT1X_DATA_OUT_PIN | SHT1X_CLOCK_PIN, SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN,
	/* transmission start */
	SHT1X_DATA_OUT_PIN | SHT1X_CLOCK_PIN, SHT1X_DATA_OUT_PIN | SHT1X_CLOCK_PIN,
	SHT1X_CLOCK_PIN, SHT1X_CLOCK_PIN,
	0x00, 0x00,
	SHT1X_CLOCK_PIN, SHT1X_CLOCK_PIN,
	SHT1X_DATA_OUT_PIN | SHT1X_CLOCK_PIN, SHT1X_DATA_OUT_PIN | SHT1X_CLOCK_PIN,
	SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN,
	0x00, 0x00,
	/* address */
	0x00, 0x00, SHT1X_CLOCK_PIN, SHT1X_CLOCK_PIN, /* a2 */
	0x00, 0x00, SHT1X_CLOCK_PIN, SHT1X_CLOCK_PIN, /* a1 */
	0x00, 0x00, SHT1X_CLOCK_PIN, SHT1X_CLOCK_PIN, /* a0 */
};

/*
 * The bit pattern for "Measure Temperature" command.
 * 0x00011
 */
static const uint8_t measure_temperature_pattern[] = {
	0x00, 0x00,	0x00, SHT1X_CLOCK_PIN, /* c4 */
	0x00, 0x00,	0x00, SHT1X_CLOCK_PIN, /* c3 */
	0x00, 0x00,	0x00, SHT1X_CLOCK_PIN, /* c2 */
	0x00, SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN | SHT1X_CLOCK_PIN, /* c1 */
	SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN | SHT1X_CLOCK_PIN, /* c0 */
};

#define SHT1X_TEMPERATURE_READ_CMD	(0x03)

/*
 * The bit pattern for "Measure Relative Humidity" command.
 * 0x00101
 */
static const uint8_t measure_moisture_pattern[] = {
	0x00, 0x00, 0x00, SHT1X_CLOCK_PIN, /* c4 */
	0x00, 0x00, 0x00, SHT1X_CLOCK_PIN, /* c3 */
	0x00, SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN, SHT1X_BOTH_PINS, /* c2 */
	SHT1X_DATA_OUT_PIN, 0x00,  SHT1X_CLOCK_PIN, /* c1 */
	0x00, SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN, SHT1X_BOTH_PINS, /* c0 */
};

#define SHT1X_MOISTURE_READ_CMD		(0x05)

/*
 * The bit pattern for "Status Register Read" command.
 * 0b00111
 */
static const uint8_t sreg_read_pattern[] = {
	0x00, 0x00, 0x00, SHT1X_CLOCK_PIN, /* c4 */
	0x00, 0x00, 0x00, SHT1X_CLOCK_PIN, /* c3 */
	0x00, SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN, SHT1X_BOTH_PINS, /* c2 */
	SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN, SHT1X_BOTH_PINS, /* c1 */
	SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN, SHT1X_BOTH_PINS, /* c3 */
};

#define SHT1X_SREG_READ_CMD			(0x07)

/*
 * The bit pattern for "Status Register Read" command.
 * 0b00110
 */
static const uint8_t sreg_write_pattern[] = {
	0x00, 0x00, 0x00, SHT1X_CLOCK_PIN, /* c4 */
	0x00, 0x00, 0x00, SHT1X_CLOCK_PIN, /* c3 */
	0x00, SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN, SHT1X_BOTH_PINS, /* c2 */
	SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN, SHT1X_BOTH_PINS, /* c1 */
	SHT1X_DATA_OUT_PIN, 0x00, 0x00, SHT1X_CLOCK_PIN, /* c0 */
};

/*
 * The bit pattern for "Soft Reset" command.
 * 0b11110
 */
static const uint8_t soft_reset_pattern[] = {
	0x00, SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN, SHT1X_BOTH_PINS, /* c4 */
	SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN, SHT1X_BOTH_PINS, /* c3 */
	SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN, SHT1X_BOTH_PINS, /* c2 */
	SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN, SHT1X_BOTH_PINS, /* c1 */
	SHT1X_DATA_OUT_PIN, 0x00, 0x00, SHT1X_CLOCK_PIN, /* c0 */
};


static const sht1x_state_t states[] = {
	/* SHT1X_SIDX_END */				{SHT1X_STATE_OUTPUT_DONE,						{SHT1X_SIDX_END, SHT1X_SIDX_END}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_FAIL */				{SHT1X_STATE_OUTPUT_DONE,						{SHT1X_SIDX_FAIL, SHT1X_SIDX_FAIL}, {SHT1X_ERROR_UNKNOWN, SHT1X_ERROR_UNKNOWN}},

	/* Read Temperature */
	/* SHT1X_SIDX_SENSOR_FIN */			{SHT1X_STATE_OUTPUT_TIMER_ENABLE,				{SHT1X_SIDX_SENSOR_ACK, SHT1X_SIDX_SENSOR_ACK}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},

	/* SHT1X_SIDX_SENSOR_ACK */			{SHT1X_STATE_OUTPUT_OUTPUT_ACK_START,			{SHT1X_SIDX_SENSOR_ACKC, SHT1X_SIDX_SENSOR_ACKC}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_ACKC */		{SHT1X_STATE_OUTPUT_OUTPUT_ACK_RISING_EDGE,		{SHT1X_SIDX_SENSOR_ACKE, SHT1X_SIDX_SENSOR_ACKE}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_ACKE */		{SHT1X_STATE_OUTPUT_OUTPUT_ACK_WAIT,			{SHT1X_SIDX_SENSOR_WAIT_READY, SHT1X_SIDX_FAIL}, {SHT1X_ERROR_OK, SHT1X_ERROR_NO_CMD_ACK}},

	/* SHT1X_SIDX_SENSOR_WAIT_READY */	{SHT1X_STATE_OUTPUT_WAIT_READY,					{SHT1X_SIDX_SENSOR_DATA_15, SHT1X_SIDX_SENSOR_DATA_15}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},

	/* SHT1X_SIDX_SENSOR_DATA_15 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_15C, SHT1X_SIDX_SENSOR_DATA_15C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_15C */	{SHT1X_STATE_OUTPUT_DATA_FALLING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_14, SHT1X_SIDX_SENSOR_DATA_14}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_14 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_14C, SHT1X_SIDX_SENSOR_DATA_14C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_14C */	{SHT1X_STATE_OUTPUT_DATA_FALLING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_13, SHT1X_SIDX_SENSOR_DATA_13}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_13 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_13C, SHT1X_SIDX_SENSOR_DATA_13C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_13C */	{SHT1X_STATE_OUTPUT_DATA_FALLING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_12, SHT1X_SIDX_SENSOR_DATA_12}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_12 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_12C, SHT1X_SIDX_SENSOR_DATA_12C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_12C */	{SHT1X_STATE_OUTPUT_DATA_FALLING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_11, SHT1X_SIDX_SENSOR_DATA_11}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_11 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_11C, SHT1X_SIDX_SENSOR_DATA_11C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_11C */	{SHT1X_STATE_OUTPUT_DATA_FALLING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_10, SHT1X_SIDX_SENSOR_DATA_10}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_10 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_10C, SHT1X_SIDX_SENSOR_DATA_10C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_10C */	{SHT1X_STATE_OUTPUT_DATA_FALLING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_9, SHT1X_SIDX_SENSOR_DATA_9}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_9 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_9C, SHT1X_SIDX_SENSOR_DATA_9C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_9C */		{SHT1X_STATE_OUTPUT_DATA_FALLING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_8, SHT1X_SIDX_SENSOR_DATA_8}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_8 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_8C, SHT1X_SIDX_SENSOR_DATA_8C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_8C */		{SHT1X_STATE_OUTPUT_DATA_FALLING_EDGE,			{SHT1X_SIDX_SENSOR_BYTE2_ACKS, SHT1X_SIDX_SENSOR_BYTE2_ACKS}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},

	/* SHT1X_SIDX_SENSOR_BYTE2_ACKS */	{SHT1X_STATE_OUTPUT_INPUT_ACK_START,			{SHT1X_SIDX_SENSOR_BYTE2_ACK, SHT1X_SIDX_SENSOR_BYTE2_ACK}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_BYTE2_ACK */	{SHT1X_STATE_OUTPUT_INPUT_ACK_RISING_EDGE,		{SHT1X_SIDX_SENSOR_BYTE2_ACKC, SHT1X_SIDX_SENSOR_BYTE2_ACKC}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_BYTE2_ACKC */	{SHT1X_STATE_OUTPUT_INPUT_ACK_FALLING_EDGE,		{SHT1X_SIDX_SENSOR_DATA_7, SHT1X_SIDX_SENSOR_DATA_7}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},

	/* SHT1X_SIDX_SENSOR_DATA_7 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_7C, SHT1X_SIDX_SENSOR_DATA_7C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_7C */		{SHT1X_STATE_OUTPUT_DATA_FALLING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_6, SHT1X_SIDX_SENSOR_DATA_6}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_6 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_6C, SHT1X_SIDX_SENSOR_DATA_6C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_6C */		{SHT1X_STATE_OUTPUT_DATA_FALLING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_5, SHT1X_SIDX_SENSOR_DATA_5}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_5 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_5C, SHT1X_SIDX_SENSOR_DATA_5C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_5C */		{SHT1X_STATE_OUTPUT_DATA_FALLING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_4, SHT1X_SIDX_SENSOR_DATA_4}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_4 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_4C, SHT1X_SIDX_SENSOR_DATA_4C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_4C */		{SHT1X_STATE_OUTPUT_DATA_FALLING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_3, SHT1X_SIDX_SENSOR_DATA_3}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_3 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_3C, SHT1X_SIDX_SENSOR_DATA_3C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_3C */		{SHT1X_STATE_OUTPUT_DATA_FALLING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_2, SHT1X_SIDX_SENSOR_DATA_2}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_2 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_2C, SHT1X_SIDX_SENSOR_DATA_2C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_2C */		{SHT1X_STATE_OUTPUT_DATA_FALLING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_1, SHT1X_SIDX_SENSOR_DATA_1}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_1 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_1C, SHT1X_SIDX_SENSOR_DATA_1C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_1C */		{SHT1X_STATE_OUTPUT_DATA_FALLING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_0, SHT1X_SIDX_SENSOR_DATA_0}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_0 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SENSOR_DATA_0C, SHT1X_SIDX_SENSOR_DATA_0C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_DATA_0C */		{SHT1X_STATE_OUTPUT_DATA_FALLING_EDGE,			{SHT1X_SIDX_SENSOR_BYTE1_ACKS, SHT1X_SIDX_SENSOR_BYTE1_ACKS}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},

	/* SHT1X_SIDX_SENSOR_BYTE1_ACKS */	{SHT1X_STATE_OUTPUT_INPUT_ACK_START,			{SHT1X_SIDX_SENSOR_BYTE1_ACK, SHT1X_SIDX_SENSOR_BYTE1_ACK}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_BYTE1_ACK */	{SHT1X_STATE_OUTPUT_INPUT_ACK_RISING_EDGE,		{SHT1X_SIDX_SENSOR_BYTE1_ACKC, SHT1X_SIDX_SENSOR_BYTE1_ACKC}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_BYTE1_ACKC */	{SHT1X_STATE_OUTPUT_INPUT_ACK_FALLING_EDGE,		{SHT1X_SIDX_SENSOR_CRC_7, SHT1X_SIDX_SENSOR_CRC_7}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},

	/* SHT1X_SIDX_SENSOR_CRC_7 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SENSOR_CRC_7C, SHT1X_SIDX_SENSOR_CRC_7C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_CRC_7C */		{SHT1X_STATE_OUTPUT_CRC_FALLING_EDGE,			{SHT1X_SIDX_SENSOR_CRC_6, SHT1X_SIDX_SENSOR_CRC_6}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_CRC_6 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SENSOR_CRC_6C, SHT1X_SIDX_SENSOR_CRC_6C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_CRC_6C */		{SHT1X_STATE_OUTPUT_CRC_FALLING_EDGE,			{SHT1X_SIDX_SENSOR_CRC_5, SHT1X_SIDX_SENSOR_CRC_5}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_CRC_5 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SENSOR_CRC_5C, SHT1X_SIDX_SENSOR_CRC_5C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_CRC_5C */		{SHT1X_STATE_OUTPUT_CRC_FALLING_EDGE,			{SHT1X_SIDX_SENSOR_CRC_4, SHT1X_SIDX_SENSOR_CRC_4}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_CRC_4 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SENSOR_CRC_4C, SHT1X_SIDX_SENSOR_CRC_4C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_CRC_4C */		{SHT1X_STATE_OUTPUT_CRC_FALLING_EDGE,			{SHT1X_SIDX_SENSOR_CRC_3, SHT1X_SIDX_SENSOR_CRC_3}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_CRC_3 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SENSOR_CRC_3C, SHT1X_SIDX_SENSOR_CRC_3C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_CRC_3C */		{SHT1X_STATE_OUTPUT_CRC_FALLING_EDGE,			{SHT1X_SIDX_SENSOR_CRC_2, SHT1X_SIDX_SENSOR_CRC_2}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_CRC_2 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SENSOR_CRC_2C, SHT1X_SIDX_SENSOR_CRC_2C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_CRC_2C */		{SHT1X_STATE_OUTPUT_CRC_FALLING_EDGE,			{SHT1X_SIDX_SENSOR_CRC_1, SHT1X_SIDX_SENSOR_CRC_1}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_CRC_1 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SENSOR_CRC_1C, SHT1X_SIDX_SENSOR_CRC_1C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_CRC_1C */		{SHT1X_STATE_OUTPUT_CRC_FALLING_EDGE,			{SHT1X_SIDX_SENSOR_CRC_0, SHT1X_SIDX_SENSOR_CRC_0}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_CRC_0 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SENSOR_CRC_0C, SHT1X_SIDX_SENSOR_CRC_0C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_CRC_0C */		{SHT1X_STATE_OUTPUT_CRC_FALLING_EDGE,			{SHT1X_SIDX_SENSOR_CRC_ACK, SHT1X_SIDX_SENSOR_CRC_ACK}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},

	/* SHT1X_SIDX_SENSOR_CRC_ACKS */	{SHT1X_STATE_OUTPUT_INPUT_ACK_START,			{SHT1X_SIDX_SENSOR_CRC_ACK, SHT1X_SIDX_SENSOR_CRC_ACK}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_CRC_ACK */		{SHT1X_STATE_OUTPUT_INPUT_ACK_RISING_EDGE,		{SHT1X_SIDX_SENSOR_CRC_ACKC, SHT1X_SIDX_SENSOR_CRC_ACKC}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SENSOR_CRC_ACKC */	{SHT1X_STATE_OUTPUT_INPUT_ACK_FALLING_EDGE,		{SHT1X_SIDX_END, SHT1X_SIDX_END}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},

	/* Status Register Read */
	/* SHT1X_SIDX_SREGR_FIN */			{SHT1X_STATE_OUTPUT_TIMER_ENABLE,				{SHT1X_SIDX_SREGR_ACK, SHT1X_SIDX_SREGR_ACK},	{SHT1X_ERROR_OK, SHT1X_ERROR_OK}},

	/* SHT1X_SIDX_SREGR_ACK */			{SHT1X_STATE_OUTPUT_OUTPUT_ACK_START,			{SHT1X_SIDX_SREGR_ACKC, SHT1X_SIDX_SREGR_ACKC}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_ACKC */			{SHT1X_STATE_OUTPUT_OUTPUT_ACK_RISING_EDGE,		{SHT1X_SIDX_SREGR_ACKE, SHT1X_SIDX_SREGR_ACKE}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_ACKE */			{SHT1X_STATE_OUTPUT_OUTPUT_ACK_FALLING_EDGE,	{SHT1X_SIDX_SREGR_DATA_7, SHT1X_SIDX_FAIL}, {SHT1X_ERROR_OK, SHT1X_ERROR_NO_CMD_ACK}},

	/* SHT1X_SIDX_SREGR_DATA_7 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SREGR_DATA_7C, SHT1X_SIDX_SREGR_DATA_7C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_DATA_7C */		{SHT1X_STATE_OUTPUT_DATA_FALLING_EDGE,			{SHT1X_SIDX_SREGR_DATA_6, SHT1X_SIDX_SREGR_DATA_6}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_DATA_6 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SREGR_DATA_6C, SHT1X_SIDX_SREGR_DATA_6C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_DATA_6C */		{SHT1X_STATE_OUTPUT_DATA_FALLING_EDGE,			{SHT1X_SIDX_SREGR_DATA_5, SHT1X_SIDX_SREGR_DATA_5}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_DATA_5 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SREGR_DATA_5C, SHT1X_SIDX_SREGR_DATA_5C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_DATA_5C */		{SHT1X_STATE_OUTPUT_DATA_FALLING_EDGE,			{SHT1X_SIDX_SREGR_DATA_4, SHT1X_SIDX_SREGR_DATA_4}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_DATA_4 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SREGR_DATA_4C, SHT1X_SIDX_SREGR_DATA_4C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_DATA_4C */		{SHT1X_STATE_OUTPUT_DATA_FALLING_EDGE,			{SHT1X_SIDX_SREGR_DATA_3, SHT1X_SIDX_SREGR_DATA_3}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_DATA_3 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SREGR_DATA_3C, SHT1X_SIDX_SREGR_DATA_3C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_DATA_3C */		{SHT1X_STATE_OUTPUT_DATA_FALLING_EDGE,			{SHT1X_SIDX_SREGR_DATA_2, SHT1X_SIDX_SREGR_DATA_2}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_DATA_2 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SREGR_DATA_2C, SHT1X_SIDX_SREGR_DATA_2C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_DATA_2C */		{SHT1X_STATE_OUTPUT_DATA_FALLING_EDGE,			{SHT1X_SIDX_SREGR_DATA_1, SHT1X_SIDX_SREGR_DATA_1}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_DATA_1 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SREGR_DATA_1C, SHT1X_SIDX_SREGR_DATA_1C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_DATA_1C */		{SHT1X_STATE_OUTPUT_DATA_FALLING_EDGE,			{SHT1X_SIDX_SREGR_DATA_0, SHT1X_SIDX_SREGR_DATA_0}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_DATA_0 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SREGR_DATA_0C, SHT1X_SIDX_SREGR_DATA_0C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_DATA_0C */		{SHT1X_STATE_OUTPUT_DATA_FALLING_EDGE,			{SHT1X_SIDX_SREGR_DATA_ACKS, SHT1X_SIDX_SREGR_DATA_ACKS}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},

	/* SHT1X_SIDX_SREGR_DATA_ACKS */	{SHT1X_STATE_OUTPUT_INPUT_ACK_START,			{SHT1X_SIDX_SREGR_DATA_ACK, SHT1X_SIDX_SREGR_DATA_ACK}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_DATA_ACK */		{SHT1X_STATE_OUTPUT_INPUT_ACK_RISING_EDGE,		{SHT1X_SIDX_SREGR_DATA_ACKC, SHT1X_SIDX_SREGR_DATA_ACKC}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_DATA_ACKC */	{SHT1X_STATE_OUTPUT_INPUT_ACK_FALLING_EDGE,		{SHT1X_SIDX_SREGR_CRC_7, SHT1X_SIDX_SREGR_CRC_7}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},

	/* SHT1X_SIDX_SREGR_CRC_7 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SREGR_CRC_7C, SHT1X_SIDX_SREGR_CRC_7C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_CRC_7C */		{SHT1X_STATE_OUTPUT_CRC_FALLING_EDGE,			{SHT1X_SIDX_SREGR_CRC_6, SHT1X_SIDX_SREGR_CRC_6}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_CRC_6 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SREGR_CRC_6C, SHT1X_SIDX_SREGR_CRC_6C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_CRC_6C */		{SHT1X_STATE_OUTPUT_CRC_FALLING_EDGE,			{SHT1X_SIDX_SREGR_CRC_5, SHT1X_SIDX_SREGR_CRC_5}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_CRC_5 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SREGR_CRC_5C, SHT1X_SIDX_SREGR_CRC_5C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_CRC_5C */		{SHT1X_STATE_OUTPUT_CRC_FALLING_EDGE,			{SHT1X_SIDX_SREGR_CRC_4, SHT1X_SIDX_SREGR_CRC_4}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_CRC_4 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SREGR_CRC_4C, SHT1X_SIDX_SREGR_CRC_4C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_CRC_4C */		{SHT1X_STATE_OUTPUT_CRC_FALLING_EDGE,			{SHT1X_SIDX_SREGR_CRC_3, SHT1X_SIDX_SREGR_CRC_3}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_CRC_3 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SREGR_CRC_3C, SHT1X_SIDX_SREGR_CRC_3C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_CRC_3C */		{SHT1X_STATE_OUTPUT_CRC_FALLING_EDGE,			{SHT1X_SIDX_SREGR_CRC_2, SHT1X_SIDX_SREGR_CRC_2}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_CRC_2 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SREGR_CRC_2C, SHT1X_SIDX_SREGR_CRC_2C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_CRC_2C */		{SHT1X_STATE_OUTPUT_CRC_FALLING_EDGE,			{SHT1X_SIDX_SREGR_CRC_1, SHT1X_SIDX_SREGR_CRC_1}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_CRC_1 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SREGR_CRC_1C, SHT1X_SIDX_SREGR_CRC_1C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_CRC_1C */		{SHT1X_STATE_OUTPUT_CRC_FALLING_EDGE,			{SHT1X_SIDX_SREGR_CRC_0, SHT1X_SIDX_SREGR_CRC_0}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_CRC_0 */		{SHT1X_STATE_OUTPUT_READ_RISING_EDGE,			{SHT1X_SIDX_SREGR_CRC_0C, SHT1X_SIDX_SREGR_CRC_0C}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_CRC_0C */		{SHT1X_STATE_OUTPUT_CRC_FALLING_EDGE,			{SHT1X_SIDX_SREGR_CRC_ACKS, SHT1X_SIDX_SREGR_CRC_ACKS}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},

	/* SHT1X_SIDX_SREGR_CRC_ACKS */		{SHT1X_STATE_OUTPUT_INPUT_ACK_START,			{SHT1X_SIDX_SREGR_CRC_ACK, SHT1X_SIDX_SREGR_CRC_ACK}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_CRC_ACK */		{SHT1X_STATE_OUTPUT_INPUT_ACK_RISING_EDGE,		{SHT1X_SIDX_SREGR_CRC_ACKC, SHT1X_SIDX_SREGR_CRC_ACKC}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGR_CRC_ACKC */		{SHT1X_STATE_OUTPUT_INPUT_ACK_FALLING_EDGE,		{SHT1X_SIDX_END, SHT1X_SIDX_END}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},

	/* Status Register Write */
	/* SHT1X_SIDX_SREGW_FIN */			{SHT1X_STATE_OUTPUT_TIMER_ENABLE,				{SHT1X_SIDX_SREGW_ACK, SHT1X_SIDX_SREGW_ACK}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},

	/* SHT1X_SIDX_SREGW_ACK */			{SHT1X_STATE_OUTPUT_OUTPUT_ACK_START,			{SHT1X_SIDX_SREGW_ACKC, SHT1X_SIDX_SREGW_ACKC}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGW_ACKC */			{SHT1X_STATE_OUTPUT_OUTPUT_ACK_RISING_EDGE,		{SHT1X_SIDX_SREGW_ACKE, SHT1X_SIDX_SREGW_ACKE}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGW_ACKE */			{SHT1X_STATE_OUTPUT_OUTPUT_ACK_FALLING_EDGE,	{SHT1X_SIDX_SREGW_PAYLOAD, SHT1X_SIDX_FAIL}, {SHT1X_ERROR_OK, SHT1X_ERROR_NO_CMD_ACK}},

	/* SHT1X_SIDX_SREGW_PAYLOAD */		{SHT1X_STATE_OUTPUT_PAYLOAD,					{SHT1X_SIDX_SREGW_PAYLOAD_FIN, SHT1X_SIDX_SREGW_PAYLOAD_FIN}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGW_PAYLOAD_FIN */	{SHT1X_STATE_OUTPUT_TIMER_ENABLE,				{SHT1X_SIDX_SREGW_PAYLOAD_ACK, SHT1X_SIDX_SREGW_PAYLOAD_ACK}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},

	/* SHT1X_SIDX_SREGW_PAYLOAD_ACK */	{SHT1X_STATE_OUTPUT_OUTPUT_ACK_START,			{SHT1X_SIDX_SREGW_PAYLOAD_ACKC, SHT1X_SIDX_SREGW_PAYLOAD_ACKC}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGW_PAYLOAD_ACKC */	{SHT1X_STATE_OUTPUT_OUTPUT_ACK_RISING_EDGE,		{SHT1X_SIDX_SREGW_PAYLOAD_ACKE, SHT1X_SIDX_SREGW_PAYLOAD_ACKE}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SREGW_PAYLOAD_ACKE */	{SHT1X_STATE_OUTPUT_OUTPUT_ACK_FALLING_EDGE,	{SHT1X_SIDX_END, SHT1X_SIDX_FAIL}, {SHT1X_ERROR_OK, SHT1X_ERROR_NO_PAYLOAD_ACK}},

	/* Software Reset */
	/* SHT1X_SIDX_SOFT_RESET_FIN */		{SHT1X_STATE_OUTPUT_TIMER_ENABLE,				{SHT1X_SIDX_SOFT_RESET_ACK, SHT1X_SIDX_SOFT_RESET_ACK},  {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SOFT_RESET_ACK */		{SHT1X_STATE_OUTPUT_OUTPUT_ACK_START,			{SHT1X_SIDX_SOFT_RESET_ACKC, SHT1X_SIDX_SOFT_RESET_ACKC}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SOFT_RESET_ACKC */	{SHT1X_STATE_OUTPUT_OUTPUT_ACK_RISING_EDGE,		{SHT1X_SIDX_SOFT_RESET_ACKE, SHT1X_SIDX_SOFT_RESET_ACKE}, {SHT1X_ERROR_OK, SHT1X_ERROR_OK}},
	/* SHT1X_SIDX_SOFT_RESET_ACKE */	{SHT1X_STATE_OUTPUT_OUTPUT_ACK_FALLING_EDGE,	{SHT1X_SIDX_END, SHT1X_SIDX_FAIL}, {SHT1X_ERROR_OK, SHT1X_ERROR_NO_CMD_ACK}},
};

/*
 * CRC-8 lookup table for polynomial x^8 + x^5 + x^4 + 1
 * For more information see https://github.com/zolkko/blumenplace-uc/wiki/SHT1X-CRC-8-calculation
 */
const static uint8_t crc8_lut[] = {
	0,   49,  98,  83,  196, 245, 166, 151, 185, 136, 219, 234, 125, 76,  31,  46,
	67,  114, 33,  16,  135, 182, 229, 212, 250, 203, 152, 169, 62,  15,  92,  109,
	134, 183, 228, 213, 66,  115, 32,  17,  63,  14,  93,  108, 251, 202, 153, 168,
	197, 244, 167, 150, 1,   48,  99,  82,  124, 77,  30,  47,  184, 137, 218, 235,
	61,  12,  95,  110, 249, 200, 155, 170, 132, 181, 230, 215, 64,  113, 34,  19,
	126, 79,  28,  45,  186, 139, 216, 233, 199, 246, 165, 148, 3,   50,  97,  80,
	187, 138, 217, 232, 127, 78,  29,  44,  2,   51,  96,  81,  198, 247, 164, 149,
	248, 201, 154, 171, 60,  13,  94,  111, 65,  112, 35,  18,  133, 180, 231, 214,
	122, 75,  24,  41,  190, 143, 220, 237, 195, 242, 161, 144, 7,   54,  101, 84,
	57,  8,   91,  106, 253, 204, 159, 174, 128, 177, 226, 211, 68,  117, 38,  23,
	252, 205, 158, 175, 56,  9,   90,  107, 69,  116, 39,  22,  129, 176, 227, 210,
	191, 142, 221, 236, 123, 74,  25,  40,  6,   55,  100, 85,  194, 243, 160, 145,
	71,  118, 37,  20,  131, 178, 225, 208, 254, 207, 156, 173, 58,  11,  88,  105,
	4,   53,  102, 87,  192, 241, 162, 147, 189, 140, 223, 238, 121, 72,  27,  42,
	193, 240, 163, 146, 5,   52,  103, 86,  120, 73,  26,  43,  188, 141, 222, 239,
	130, 179, 224, 209, 70,  119, 36,  21,  59,  10,  89,  104, 255, 206, 157, 172
};

/*
 * Temperature calculation coefficients
 * These values were taken from sht1x datasheet.
 */
static const float temperature_d1 = -39.6f;

static const float temperature_highres_d2 = 0.01f;

static const float temperature_lowres_d2 = 0.04f;

static const float moisture_c1 = -2.0468f;

static const float moisture_highres_c2 = 0.0367f;

static const float moisture_lowres_c2 = 0.5872f;

static const float moisture_highres_c3 = -1.5955e-6;

static const float moisture_lowres_c3 = -4.0845e-4;


static sht1x_device_t device;


static uint8_t sht1x_reverse_bits(uint8_t value);

static uint8_t sht1x_crc(uint8_t * data, size_t data_len, uint8_t initial_crc);

static void sht1x_udma_set_buffer(void * data, uint32_t transfer_size);

static void sht1x_timer_start(void);

static void sht1x_timer_stop(void);


static inline void sht1x_gpio_init(void);

static inline void sht1x_timer_init(void);

static inline void sht1x_udma_init(void);


static void sht1x_udma_set_buffer(void * data, uint32_t transfer_size);

static void sht1x_command_prepare(const uint8_t * command, size_t command_size);

static void sht1x_command_payload_prepare(uint8_t * buffer, uint8_t value);

static void sht1x_device_state_prepare(sht1x_sidx_t next_state);

static inline void sht1x_transmission_done(void);

static sht1x_error_t sht1x_sensor_read(uint8_t command, const uint8_t * command_pattern, size_t command_pattern_size, uint16_t * sensor_output);

static void sht1x_process();


static inline void sht1x_gpio_reset_pins(void);

static inline void sht1x_gpio_interrupt_enable();

static inline void sht1x_gpio_interrupt_disable();


sht1x_error_t sht1x_temperature_read(float * temperature)
{
	uint16_t sensor_output;
	sht1x_error_t result = sht1x_sensor_read(SHT1X_TEMPERATURE_READ_CMD, measure_temperature_pattern, sizeof(measure_temperature_pattern), &sensor_output);
	if (result == SHT1X_ERROR_OK && temperature) {
		*temperature = temperature_d1 + (sensor_output * ((device.status & SHT1X_SREG_LOW_RES_bm) ? temperature_lowres_d2 : temperature_highres_d2));
	}
	return result;
}


sht1x_error_t sht1x_moisture_read(float * moisture)
{
	uint16_t sensor_output;
	sht1x_error_t result = sht1x_sensor_read(SHT1X_MOISTURE_READ_CMD, measure_moisture_pattern, sizeof(measure_moisture_pattern), &sensor_output);
	if (result == SHT1X_ERROR_OK && moisture) {
		bool low_res = device.status & SHT1X_SREG_LOW_RES_bm;
		*moisture =  moisture_c1 + ((low_res ? moisture_lowres_c2 : moisture_highres_c2) * sensor_output) +
									(sensor_output * sensor_output * (low_res ? moisture_lowres_c3 : moisture_highres_c3));
	}
	return result;
}


sht1x_error_t sht1x_status_write(uint8_t status)
{
	sht1x_error_t result = SHT1X_ERROR_BUSY;

	if (xSemaphoreTake(device.lock, portMAX_DELAY) == pdTRUE) {
		sht1x_command_prepare(sreg_write_pattern, sizeof(sreg_write_pattern));
		sht1x_command_payload_prepare(device.cmd_payload, status & SHT1X_SREG_bm);
		sht1x_device_state_prepare(SHT1X_SIDX_SREGW_FIN);

		sht1x_udma_set_buffer(device.cmd, sizeof(trans_start_pattern) + sizeof(sreg_write_pattern));

		TimerLoadSet(SHT1X_TIMER_BASE, SHT1X_TIMER, SHT1X_CLK_NR);
		TimerIntClear(SHT1X_TIMER_BASE, TIMER_TIMA_TIMEOUT);
		TimerEnable(SHT1X_TIMER_BASE, SHT1X_TIMER);

		if (xSemaphoreTake(device.interrupt_semaphore, portMAX_DELAY) == pdTRUE) {
			result = device.error;
			device.status = status;
			device.crc_init = sht1x_reverse_bits(status);
		}
		xSemaphoreGive(device.lock);
	}
	return result;
}


sht1x_error_t sht1x_status_read(uint8_t * status)
{
	sht1x_error_t result = SHT1X_ERROR_BUSY;

	if (xSemaphoreTake(device.lock, portMAX_DELAY) == pdTRUE) {
		sht1x_command_prepare(sreg_read_pattern, sizeof(sreg_read_pattern));
		sht1x_device_state_prepare(SHT1X_SIDX_SREGR_FIN);

		sht1x_udma_set_buffer((void *) device.cmd, sizeof(trans_start_pattern) + sizeof(sreg_read_pattern));

		TimerLoadSet(SHT1X_TIMER_BASE, SHT1X_TIMER, SHT1X_CLK_NR);
		TimerIntClear(SHT1X_TIMER_BASE, TIMER_TIMA_TIMEOUT);
		TimerEnable(SHT1X_TIMER_BASE, SHT1X_TIMER);

		if (xSemaphoreTake(device.interrupt_semaphore, portMAX_DELAY) == pdTRUE) {
			result = device.error;
			if (result == SHT1X_ERROR_OK) {
				uint8_t data[] = {SHT1X_SREG_READ_CMD, device.data & 0xff, sht1x_reverse_bits(device.crc)};
				uint8_t crc = sht1x_crc(data, sizeof(data), device.crc_init);

				if (crc == 0) {
					device.status = device.data & 0xff;
					device.crc_init = sht1x_reverse_bits(device.status);
					if (status != NULL) {
						*status = device.status;
					}
				} else {
					result = SHT1X_ERROR_INVALID_CRC;
				}
			}
		}
		xSemaphoreGive(device.lock);
	}

	return result;
}


sht1x_error_t sht1x_software_reset(void)
{
	sht1x_error_t result = SHT1X_ERROR_BUSY;

	if (xSemaphoreTake(device.lock, portMAX_DELAY) == pdTRUE) {
		sht1x_command_prepare(soft_reset_pattern, sizeof(soft_reset_pattern));
		sht1x_device_state_prepare(SHT1X_SIDX_SOFT_RESET_FIN);

		sht1x_udma_set_buffer((void *) device.cmd, sizeof(trans_start_pattern) + sizeof(sreg_read_pattern));

		TimerLoadSet(SHT1X_TIMER_BASE, SHT1X_TIMER, SHT1X_CLK_NR);
		TimerIntClear(SHT1X_TIMER_BASE, TIMER_TIMA_TIMEOUT);
		TimerEnable(SHT1X_TIMER_BASE, SHT1X_TIMER);

		if (xSemaphoreTake(device.interrupt_semaphore, portMAX_DELAY) == pdTRUE) {
			result = device.error;
			device.status = SHT1X_DEFAULT_STATUS;
			device.crc_init = SHT1X_DEFAULT_CRC_INIT;
		}
		xSemaphoreGive(device.lock);
	}

	return result;
}


void sht1x_init(void)
{
	device.lock = xSemaphoreCreateMutex();
	device.interrupt_semaphore = xSemaphoreCreateBinary();

	device.status = SHT1X_DEFAULT_STATUS;
	device.crc_init = SHT1X_DEFAULT_CRC_INIT;
	device.error = SHT1X_ERROR_UNKNOWN;

	sht1x_gpio_init();

	sht1x_timer_init();
	sht1x_udma_init();
}

/*
 * Initialize GPIO port to support SHT1X I/O operations.
 * Data pin is set in weak pull-up configuration.
 *
 * Unlike AVR the TM4C123 does not allow to read actual logic level from
 * output pins. That is why an addition SHT1X_DATA_IN_PIN is used.
 */
void sht1x_gpio_init(void)
{
	SysCtlPeripheralEnable(SHT1X_GPIO_PERIPH);

	GPIOIntDisable(SHT1X_PORT_BASE, SHT1X_DATA_INTERRUPT);

	GPIOPinTypeGPIOOutput(SHT1X_PORT_BASE, SHT1X_CLOCK_PIN);
	GPIOPinWrite(SHT1X_PORT_BASE, SHT1X_CLOCK_PIN, 0x00);

	GPIODirModeSet(SHT1X_PORT_BASE, SHT1X_DATA_OUT_PIN, GPIO_DIR_MODE_OUT);
	GPIOPadConfigSet(SHT1X_PORT_BASE, SHT1X_DATA_OUT_PIN, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD_WPU);
	GPIOPinWrite(SHT1X_PORT_BASE, SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN);

	GPIOPinTypeGPIOInput(SHT1X_PORT_BASE, SHT1X_DATA_IN_PIN);
	GPIOIntTypeSet(SHT1X_PORT_BASE, SHT1X_DATA_IN_PIN, GPIO_FALLING_EDGE);

	IntEnable(SHT1X_GPIO_INTERRUPT);
}

/*
 * Initializes timer to trigger an overflow interrupt every 1/SHT1X_CLOCK_HZ seconds.
 * The function also configures uDMA to trigger timer's interrupt handler.
 *
 * If uDMA is enabled and its transaction is in progress it blocks normal interrupt
 * flow of the timer.
 */
void sht1x_timer_init(void)
{
	SysCtlPeripheralEnable(SHT1X_TIMER_PERIPH);

	IntDisable(SHT1X_TIMER_INTERRUPT);
	TimerIntDisable(SHT1X_TIMER_BASE, TIMER_TIMA_TIMEOUT);
	TimerDisable(SHT1X_TIMER_BASE, SHT1X_TIMER);

	TimerConfigure(SHT1X_TIMER_BASE, TIMER_CFG_A_PERIODIC);
	TimerPrescaleSet(SHT1X_TIMER_BASE, SHT1X_TIMER, 0);
	TimerClockSourceSet(SHT1X_TIMER_BASE, TIMER_CLOCK_SYSTEM);
	TimerLoadSet(SHT1X_TIMER_BASE, SHT1X_TIMER, SHT1X_CLK_NR);

	TimerDMAEventSet(SHT1X_TIMER_BASE, TIMER_DMA_TIMEOUT_A);

	TimerIntClear(SHT1X_TIMER_BASE, TIMER_TIMA_TIMEOUT);
	IntEnable(SHT1X_TIMER_INTERRUPT);
}

/*
 * The function enables and configures uDMA channel in burst mode
 * because the timer module supports only this type of transfer.
 */
void sht1x_udma_init(void)
{
	SysCtlPeripheralEnable(SHT1X_UDMA_PERIPH);

	uDMAEnable();
	uDMAControlBaseSet(UDMA_CTL_TBL);

	IntEnable(INT_UDMAERR);

	uDMAChannelAttributeEnable(SHT1X_UDMA_CHANNEL, UDMA_ATTR_USEBURST);
	uDMAChannelAttributeDisable(SHT1X_UDMA_CHANNEL, UDMA_ATTR_ALTSELECT | UDMA_ATTR_HIGH_PRIORITY | UDMA_ATTR_REQMASK);
}


sht1x_error_t sht1x_sensor_read(uint8_t command, const uint8_t * command_pattern, size_t command_pattern_size, uint16_t * sensor_output)
{
	sht1x_error_t result = SHT1X_ERROR_BUSY;

	if (xSemaphoreTake(device.lock, portMAX_DELAY) == pdTRUE) {
		sht1x_command_prepare(command_pattern, command_pattern_size);
		sht1x_device_state_prepare(SHT1X_SIDX_SENSOR_FIN);

		sht1x_udma_set_buffer((void *)device.cmd, sizeof(trans_start_pattern) + command_pattern_size);
		TimerLoadSet(SHT1X_TIMER_BASE, SHT1X_TIMER, SHT1X_CLK_NR);
		sht1x_timer_start();

		if (xSemaphoreTake(device.interrupt_semaphore, portMAX_DELAY) == pdTRUE) {
			result = device.error;
			if (result == SHT1X_ERROR_OK) {
				uint8_t data[] = {command, (device.data >> 8) & 0xff, device.data & 0xff, sht1x_reverse_bits(device.crc)};
				uint8_t crc = sht1x_crc(data, sizeof(data), device.crc_init);
				if (crc == 0) {
					if (sensor_output != NULL) {
						*sensor_output = device.data;
					}
				} else {
					result = SHT1X_ERROR_INVALID_CRC;
				}
			}
		}

		xSemaphoreGive(device.lock);
	}
	return result;
}

/*
 * Sets CLOCK line low and DATA line high.
 */
void sht1x_gpio_reset_pins(void)
{
	GPIOPinWrite(SHT1X_PORT_BASE, SHT1X_BOTH_PINS, SHT1X_DATA_OUT_PIN);
}


static inline void sht1x_gpio_interrupt_enable()
{
	GPIOIntClear(SHT1X_PORT_BASE, SHT1X_DATA_INTERRUPT);
	GPIOIntEnable(SHT1X_PORT_BASE, SHT1X_DATA_INTERRUPT);
}


static inline void sht1x_gpio_interrupt_disable()
{
	GPIOIntDisable(SHT1X_PORT_BASE, SHT1X_DATA_INTERRUPT);
}


void sht1x_timer_start(void)
{
	TimerIntClear(SHT1X_TIMER_BASE, TIMER_TIMA_TIMEOUT);
	TimerIntEnable(SHT1X_TIMER_BASE, TIMER_TIMA_TIMEOUT);
	TimerEnable(SHT1X_TIMER_BASE, SHT1X_TIMER);
}


void sht1x_timer_stop(void)
{
	TimerIntDisable(SHT1X_TIMER_BASE, TIMER_TIMA_TIMEOUT);
	TimerIntClear(SHT1X_TIMER_BASE, TIMER_TIMA_TIMEOUT);
	TimerDisable(SHT1X_TIMER_BASE, SHT1X_TIMER);
}


void sht1x_udma_set_buffer(void * data, uint32_t transfer_size)
{
	uDMAChannelControlSet(SHT1X_UDMA_CHANNEL | UDMA_PRI_SELECT, UDMA_SIZE_8 | UDMA_SRC_INC_8 | UDMA_DST_INC_NONE | UDMA_ARB_2);
	uDMAChannelTransferSet(SHT1X_UDMA_CHANNEL | UDMA_PRI_SELECT, UDMA_MODE_BASIC, data, SHT1X_DST_ADDRESS, transfer_size);

	uDMAIntClear(SHT1X_UDMA_CH_NUM);
	uDMAChannelEnable(SHT1X_UDMA_CHANNEL);
}


void sht1x_command_prepare(const uint8_t * command, size_t command_size)
{
	memcpy(device.cmd, trans_start_pattern, sizeof(trans_start_pattern));
	memcpy(&device.cmd[sizeof(trans_start_pattern)], command, command_size);
}

/*
 * shape output signal using value provided
 */
void sht1x_command_payload_prepare(uint8_t * buffer, uint8_t value)
{
	uint8_t mask;
	uint8_t data_value = 0;

	for (mask = 0x80; mask; mask >>= 1) {
		*buffer++ = data_value;

		data_value = value & mask ? SHT1X_DATA_OUT_PIN : 0x00;
		*buffer++ = data_value;

		*buffer++ = data_value;
		*buffer++ = data_value | SHT1X_CLOCK_PIN;
	}
}


void sht1x_device_state_prepare(sht1x_sidx_t next_state)
{
	device.data = 0;
	device.crc = 0;
	device.state = next_state;
	device.error = SHT1X_ERROR_OK;
}


static inline void sht1x_transmission_done(void)
{
	sht1x_gpio_interrupt_disable();
	sht1x_timer_stop();
	GPIOPinWrite(SHT1X_PORT_BASE, SHT1X_BOTH_PINS, SHT1X_DATA_OUT_PIN);
	xSemaphoreGiveFromISR(device.interrupt_semaphore, NULL);
}


void sht1x_process()
{
	const sht1x_state_t * state = &states[device.state];

	uint32_t cur_output = state->output;

	uint8_t input = (sht1x_data_in_get() & SHT1X_DATA_IN_PIN) >> SHT1X_DIN_PIN_bp;

	device.state = state->next_state[input];
	device.error = state->next_error[input];

	switch (cur_output) {
		case SHT1X_STATE_OUTPUT_TIMER_ENABLE:
			TimerIntEnable(SHT1X_TIMER_BASE, TIMER_TIMA_TIMEOUT);
			break;

		case SHT1X_STATE_OUTPUT_PAYLOAD:
			sht1x_timer_stop();
			sht1x_udma_set_buffer(device.cmd_payload, SHT1X_PAYLOAD_BUFFER_SIZE);
			TimerLoadSet(SHT1X_TIMER_BASE, SHT1X_TIMER, SHT1X_CLK_NR);
			TimerIntClear(SHT1X_TIMER_BASE, TIMER_TIMA_TIMEOUT);
			TimerEnable(SHT1X_TIMER_BASE, SHT1X_TIMER);
			break;

		case SHT1X_STATE_OUTPUT_CRC_FALLING_EDGE:
			device.crc <<= 1;
			device.crc |= input;
			GPIOPinWrite(SHT1X_PORT_BASE, SHT1X_CLOCK_PIN, 0x00);
			break;

		case SHT1X_STATE_OUTPUT_DATA_FALLING_EDGE:
			device.data <<= 1;
			device.data |= input;
			GPIOPinWrite(SHT1X_PORT_BASE, SHT1X_CLOCK_PIN, 0x00);
			break;

		case SHT1X_STATE_OUTPUT_READ_RISING_EDGE:
		case SHT1X_STATE_OUTPUT_INPUT_ACK_RISING_EDGE:
			GPIOPinWrite(SHT1X_PORT_BASE, SHT1X_CLOCK_PIN, SHT1X_CLOCK_PIN);
			break;

		case SHT1X_STATE_OUTPUT_INPUT_ACK_START:
			GPIOPinWrite(SHT1X_PORT_BASE, SHT1X_DATA_OUT_PIN, 0x00);
			break;

		case SHT1X_STATE_OUTPUT_OUTPUT_ACK_FALLING_EDGE:
			GPIOPinWrite(SHT1X_PORT_BASE, SHT1X_CLOCK_PIN, 0x00);
			break;

		case SHT1X_STATE_OUTPUT_OUTPUT_ACK_RISING_EDGE:
			GPIOPinWrite(SHT1X_PORT_BASE, SHT1X_CLOCK_PIN, SHT1X_CLOCK_PIN);
			break;

		case SHT1X_STATE_OUTPUT_INPUT_ACK_FALLING_EDGE:
		case SHT1X_STATE_OUTPUT_OUTPUT_ACK_START:
			GPIOPinWrite(SHT1X_PORT_BASE, SHT1X_CLOCK_PIN, 0x00);
			GPIOPinWrite(SHT1X_PORT_BASE, SHT1X_DATA_OUT_PIN, SHT1X_DATA_OUT_PIN);
			break;

		case SHT1X_STATE_OUTPUT_OUTPUT_ACK_WAIT:
			sht1x_timer_stop();
			TimerLoadSet(SHT1X_TIMER_BASE, SHT1X_TIMER, SHT1X_CLK_LO);
			sht1x_timer_start();
			sht1x_gpio_interrupt_enable();
			GPIOPinWrite(SHT1X_PORT_BASE, SHT1X_CLOCK_PIN, 0x00);
			break;

		case SHT1X_STATE_OUTPUT_WAIT_READY:
			sht1x_gpio_interrupt_disable();
			GPIOPinWrite(SHT1X_PORT_BASE, SHT1X_BOTH_PINS, SHT1X_DATA_OUT_PIN);
			sht1x_timer_stop();
			TimerLoadSet(SHT1X_TIMER_BASE, SHT1X_TIMER, SHT1X_CLK_NR);
			sht1x_timer_start();
			break;

		case SHT1X_STATE_OUTPUT_DONE:
			sht1x_transmission_done();
			return;
	}

	if (device.error != SHT1X_ERROR_OK) {
		sht1x_transmission_done();
	}
}


void timer0a_isr_handler(void)
{
	uint32_t udma_status = uDMAIntStatus();
	uint32_t timer_status = TimerIntStatus(SHT1X_TIMER_BASE, false);

	TimerIntClear(SHT1X_TIMER_BASE, timer_status);
	uDMAIntClear(udma_status);

	if (timer_status & TIMER_TIMA_TIMEOUT) {
		sht1x_process();
	}
}


void gpioe_isr_handler(void)
{
	uint32_t gpio_status = GPIOIntStatus(SHT1X_PORT_BASE, false);
	GPIOIntClear(SHT1X_PORT_BASE, gpio_status);

	if (gpio_status & SHT1X_DATA_INTERRUPT) {
		sht1x_process();
	}
}


void udma_error_isr_handler(void)
{
	uint32_t udma_error = uDMAErrorStatusGet();
	uint32_t udma_status = uDMAIntStatus();
	uDMAIntClear(udma_status);

	if (udma_error) {
		uDMAErrorStatusClear();
	}

	device.error = SHT1X_ERROR_UDMA_FAILURE;
	sht1x_transmission_done();
}


uint8_t sht1x_reverse_bits(uint8_t value)
{
	uint8_t i;
	uint8_t reversed = value;
	for (i = 0; i < 8; i++) {
		reversed <<= 1;
		reversed |= value & 0x01;
		value >>= 1;
	}
	return reversed;
}


uint8_t sht1x_crc(uint8_t * data, size_t data_len, uint8_t initial_crc)
{
	uint8_t crc = initial_crc;
	while (data_len) {
		crc = crc8_lut[crc ^ *data];
		data++;
		data_len--;
	}
	return crc;
}
